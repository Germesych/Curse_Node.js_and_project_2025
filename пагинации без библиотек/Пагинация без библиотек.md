Отлично! Давай подробно разберем тему **пагинации без библиотек**. Мы рассмотрим, как реализовать пагинацию на сервере, используя только чистый **Node.js** и **Express.js**, без сторонних библиотек. Это полезно, если ты хочешь лучше понять, как работает пагинация "из коробки", а не полагаться на готовые решения.

---

# **Пагинация без библиотек**

Пагинация — это процесс разбивки данных на страницы, чтобы их было легче обрабатывать и отображать. Например, если у тебя есть коллекция из 1000 элементов, и ты не хочешь выводить все 1000 сразу, можно разбить эти данные на несколько страниц (например, по 10 элементов на страницу).

Основные моменты, которые нужно учитывать при реализации пагинации:
1. **Размер страницы (limit)** — сколько элементов будет отображаться на одной странице.
2. **Номер страницы (page)** — текущая страница данных.
3. **Общее количество элементов** — для того, чтобы точно определить количество страниц.
4. **Позиционирование в базе данных** — важно правильно выбрать данные для текущей страницы.

### 1. Основная логика пагинации

Для простоты предположим, что у нас есть массив данных, и мы будем реализовывать пагинацию для этого массива. В реальных приложениях пагинация часто используется при запросах к базе данных, например, для MongoDB или SQL.

### 2. Разделение данных на страницы

Предположим, у нас есть массив объектов:

```js
const data = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' },
  { id: 4, name: 'Item 4' },
  { id: 5, name: 'Item 5' },
  { id: 6, name: 'Item 6' },
  { id: 7, name: 'Item 7' },
  { id: 8, name: 'Item 8' },
  { id: 9, name: 'Item 9' },
  { id: 10, name: 'Item 10' },
  { id: 11, name: 'Item 11' },
  { id: 12, name: 'Item 12' },
  { id: 13, name: 'Item 13' },
  { id: 14, name: 'Item 14' },
  { id: 15, name: 'Item 15' },
];
```

Допустим, мы хотим реализовать пагинацию с параметрами **page** и **limit**. Например, если **limit = 5**, то на странице будет 5 элементов, а если **page = 2**, то будет выводиться вторая "порция" данных.

### 3. Реализация пагинации

Для реализации пагинации нам нужно:

1. Получить параметры **page** и **limit** из запроса.
2. Рассчитать, какие данные нужно вернуть для текущей страницы.
3. Отправить клиенту данные вместе с общей информацией о пагинации.

### Пример кода пагинации:

```js
const express = require('express');
const app = express();
const port = 3000;

const data = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' },
  { id: 4, name: 'Item 4' },
  { id: 5, name: 'Item 5' },
  { id: 6, name: 'Item 6' },
  { id: 7, name: 'Item 7' },
  { id: 8, name: 'Item 8' },
  { id: 9, name: 'Item 9' },
  { id: 10, name: 'Item 10' },
  { id: 11, name: 'Item 11' },
  { id: 12, name: 'Item 12' },
  { id: 13, name: 'Item 13' },
  { id: 14, name: 'Item 14' },
  { id: 15, name: 'Item 15' },
];

// Пагинация: limit — количество элементов на страницу, page — номер страницы
app.get('/items', (req, res) => {
  const page = parseInt(req.query.page) || 1;  // Номер страницы, по умолчанию 1
  const limit = parseInt(req.query.limit) || 5;  // Количество элементов на странице, по умолчанию 5

  // Рассчитываем индекс первого элемента на текущей странице
  const startIndex = (page - 1) * limit;

  // Получаем данные для текущей страницы
  const endIndex = page * limit;
  const paginatedData = data.slice(startIndex, endIndex);

  // Рассчитываем общее количество страниц
  const totalPages = Math.ceil(data.length / limit);

  // Отправляем ответ с данными и информацией о пагинации
  res.json({
    page,
    limit,
    totalPages,
    data: paginatedData
  });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

### 4. Объяснение работы кода:

- **page** — номер текущей страницы. Если он не передан, по умолчанию используется 1.
- **limit** — количество элементов на одной странице. Если не передан, по умолчанию 5.
- **startIndex** — это индекс первого элемента на текущей странице, который мы получаем, умножив номер страницы на размер страницы и вычитая размер страницы (чтобы правильно позиционировать).
- **endIndex** — это индекс последнего элемента на текущей странице.
- **paginatedData** — это подмножество данных, которое соответствует текущей странице.
- **totalPages** — общее количество страниц, которое мы рассчитываем, деля общее количество элементов на размер страницы.

### 5. Пример работы:

Предположим, ты отправляешь запрос на `/items?page=2&limit=5`. Ответ будет:

```json
{
  "page": 2,
  "limit": 5,
  "totalPages": 3,
  "data": [
    { "id": 6, "name": "Item 6" },
    { "id": 7, "name": "Item 7" },
    { "id": 8, "name": "Item 8" },
    { "id": 9, "name": "Item 9" },
    { "id": 10, "name": "Item 10" }
  ]
}
```

---

# **6. Улучшения**

- **Обработка ошибок**: Если пользователь укажет неверные параметры (например, отрицательное значение для `page` или `limit`), можно добавить проверки и отправлять соответствующие сообщения об ошибке.
- **Пагинация с сортировкой**: Ты можешь добавить сортировку данных по определенному полю, например, по дате или имени, используя параметр запроса (например, `sortBy`).
- **Пагинация с фильтрацией**: Можно добавить возможность фильтровать данные по определенным критериям, например, фильтровать товары по цене или категории.

---

**Задания для практики:**

1. Реализуй пагинацию для реальной базы данных, например, MongoDB. Используй аналогичную логику для расчета `startIndex` и `endIndex`.
2. Добавь обработку ошибок для пагинации. Например, если параметры `page` или `limit` не являются числами, возвращай ошибку.
3. Добавь возможность фильтрации данных в запросе (например, фильтрация товаров по категориям).
4. Реализуй сортировку данных по какому-либо полю (например, по дате создания).
